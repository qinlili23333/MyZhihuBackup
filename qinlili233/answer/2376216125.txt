单机游戏《戴森球计划》从立项一开始就将优化放在很高的位置，为什么没有「过早优化是万恶之源」的问题？
<p data-pid="7iuGfzEM">过早优化是万恶之源这句话里的过早优化，其实主要指的是全程序性的优化，也就是离不开耦合的问题，也就是因为过度耦合而造成后期扩展性可维护性不足</p><p data-pid="B3HtuzAs">但实际上程序处处有优化，不管是一个小算法的重写提速，还是对变量闭包范围的调整，这些小优化不会产生耦合的问题，因为优化范围都在每个独立的模块甚至独立的class内</p><p><br></p><p data-pid="de_9x1O8">举个例子吧，同样是块级的定义，const相比let性能表现就更好，因为const是不可重新定义的常量</p><p data-pid="2RMOz0hB">那么有些绝对不可能运行中重新定义的变量，比如版本号和一些固定的function，我把它改为用const这就是一个不会产生耦合问题的有效优化</p><hr><p data-pid="meqEW_Jb">这是我之前搜索对比const和直接定义function性能时在网上保存下来的一段代码，我自己的运行结果是用const可以平均节约95%运行时间</p><blockquote data-pid="gUz8yLRr">	const timeAstart = +new Date();<br>    let a = 1;<br>    for (let i = 0; i &lt; 1000000; i++) {<br>      function exec() {<br>        a++;<br>      }<br>      exec();<br>    }<br><br>    console.log('a耗时:', +new Date() - timeAstart);<br><br><br>    const timeBstart = +new Date();<br>    let b = 1;<br>    for (let i = 0; i &lt; 1000000; i++) {<br>      const exec = () =&gt; {<br>        b++;<br>      }<br>      exec();<br>    }<br>    console.log('b耗时:', +new Date() - timeBstart);<br><br>    const timeCstart = +new Date();<br>    let c = 1;<br>    for (let i = 0; i &lt; 1000000; i++) {<br>      const exec = function () {<br>        c++;<br>      }<br>      exec();<br>    }<br>    console.log('c耗时:', +new Date() - timeCstart);</blockquote><p data-pid="Fjj62Tqk">所以我现在都开始逐步改用const定义方法了，毕竟这种情况只针对单个方法优化，不会波及其他部分</p>
1646529964