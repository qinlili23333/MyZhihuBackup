安卓已经进入12GB时代，为什么iPhone 13还用4GB？
<p data-pid="jdbFfDBf">这个问题实际上是个Java虚拟机的问题</p><p data-pid="sAMvmexz">在Java中开发者无法手动分配内存，分配内存的工作都是运行时来完成的</p><p data-pid="OrmVzEMf">为了避免频繁的Commit内存和频繁的GC带来的性能损失，运行时都会倾向于提前Commit更大的内存，而与此同时，ART运行时本身也会产生一定额外的内存消耗，将dex2oat产生的AOT编译文件载入内存也需要消耗额外的内存</p><p data-pid="oaBRLugU">在Android上，运行时的内存管理机制由build.prop配置</p><p data-pid="9nqShLNw">就是下面这一段，我用getprop指令读取（Android10开始非root用户无法直接读取build.prop，必须使用getprop指令）</p><blockquote data-pid="7ojbZZFr">[dalvik.vm.heapgrowthlimit]: [256m]常规应用堆限制<br>[dalvik.vm.heapmaxfree]: [8m]单次GC的最大调整量<br>[dalvik.vm.heapminfree]: [2m]单次GC的最小调整量<br>[dalvik.vm.heapsize]: [512m]设置largeHeap的应用堆限制，一般为游戏等重负载应用，但一些户口本就一页的开发者喜欢滥用<br>[dalvik.vm.heapstartsize]: [8m]应用启动时的堆大小<br>[dalvik.vm.heaptargetutilization]: [0.75]堆利用率</blockquote><p data-pid="MkGJ7Otl">大部分机型的堆利用率都设定为0.75，什么意思？意思就是每个应用占用的内存里，平均只有75%甚至更少是真实使用的，剩下的25%是为了避免频繁扩堆预留的</p><p data-pid="MkGJ7Otl">android的内存管理自上到下分为三层，第一层是虚拟机本身的OOM限制，也就是上面的堆大小限制，但只约束dalvik heap，对native heap和显存没有限制，第二层是android framework层的lmk机制，内存不足时杀死占用大内存的进程，第三层是linux内核层的内存管理机制，虽然android默认开启overcommit，从而禁用了linux内核的commit限制，但是内核中的内存碎片处理算法以及zram/swap仍然是开启的</p><p data-pid="8eLfBCQ8">这种复杂的内存管理机制源于android假定所有非系统核心进程都是可随时杀死的，通过杀死进程来及时的释放内存</p><p data-pid="pVSbT7HT">而且，大部分android设备都没有独立显存，一直是内存即显存，但在8.0之前，甚至bitmap都要在dalvik heap和texture memory里重复储存，直到8.0才引入了hardware bitmap解决了这一问题</p><p data-pid="bljRGIsA">可以说android的设计思路一直都是尽可能提升大内存设备的性能表现，以牺牲小内存设备表现为代价</p><p data-pid="LwFEvgbj">当然，用jni native可以自己管理内存，但应用如果全写native那还搞个锤子Android啊，直接Ubuntu touch不香吗？</p><p><br></p><hr><p data-pid="XFimTyVP">其实所有由运行时负责内存管理的语言都有一样的问题，包括但不限于python，js，<a href="http://link.zhihu.com/?target=http%3A//vb.net/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">vb.net/</span><span class="invisible"></span></a> c#   等</p><p data-pid="ESxcfL2U">问题的本质还是在于运行时不知道开发者需要怎么样的内存分配，只能去“猜”或者说是去“适应”，所以就必然只能采取保守的大余量的策略，以免造成一些意外，比如把还有用的东西给回收掉</p><p data-pid="wPJ26yzd">就比如在cpp中，我知道这个array撑死了也不可能超过512k，那我可以选择就申请512k内存用于存放这个array。但是在java中，当我new了一个array，运行时不知道我这个array会多大，怎么办呢，那就先申请个8m内存吧，等array填充到了6m运行时发现申请的内存快填满了，赶紧再申请一个8m。假如我还是存放一个不到512k的array，在java上却一下子8m内存就这么吃掉了</p><p data-pid="tHt71x1j">就好比停车，cpp是买一个刚刚好的车位，小心的停进去，java这些运行时包裹的语言就是直接买一排车位让你随便停，停满了就再来一排车位</p><p data-pid="SkEGaiqy">从开发者角度来说，这些语言不用考虑内存申请和释放，降低了开发难度，加快了项目的开发进度，但确实容易对于需要精确管控内存的大型项目来说比较灾难，会出现为了在不能直接管理内存的情况下强行管理内存，就得想着办法去触发运行时进行GC的条件，比如写js的时候把变量定义成false甚至undefined来释放变量的办法</p><p data-pid="OI2YhUta">这其实也是方便和精确的取舍平衡，要小项目的开发方便，就要舍弃一些控制上的精确性</p>
1646716348