是谁让安卓变卡了-2021全新版
<p data-pid="K_KypJA5">在数年前我曾写过一篇同名文章发表于简书（已同步到个人小站，欢迎前往回顾）</p><a data-draft-node="block" data-draft-type="link-card" href="http://link.zhihu.com/?target=https%3A//qinlili.bid/ArticleSave/jianshu_backup/android/whyandroidslow.html" data-image="https://pic3.zhimg.com/v2-9b23654eec345c92160e84fec56fb958.jpg?source=3af55fa1" data-image-width="590" data-image-height="216" class=" wrap external" target="_blank" rel="nofollow noreferrer">[⇦][] 是谁让安卓变卡了</a><p data-pid="pwlgqq_9">在数年后的今天，我再次站出来，写一篇同名文章</p><h2>当然我的观点仍然不变，流氓开发者仍然是唯一的原因。</h2><p><br></p><h2>0x0 1202年了，该上64位了</h2><p data-pid="ecgydjLH">从2014年高通发布410之后，手机就逐步全面64位化了。到了16年之后，除了山寨机就再也没有32位的新手机出现了。也就是说，这7年以来，没有任何一款正规手机不是64位芯片的。</p><p data-pid="EeHdGhq6">在运算较大的数据时，64位最高可以达到60%以上的性能提升</p><a data-draft-node="block" data-draft-type="link-card" href="https://www.zhihu.com/answer/585542782" class="internal">Luv Letter：64位CPU与32位CPU性能有什么差距？</a><p data-pid="vSxtFNQN">而适配64位的办法非常简单，甚至可以说有手就行，native库把64位的也放进去就行了，谷歌自己也出了官方指南</p><a data-draft-node="block" data-draft-type="link-card" href="http://link.zhihu.com/?target=https%3A//developer.android.google.cn/distribute/best-practices/develop/64-bit%3Fhl%3Dzh-cn" data-image="https://pic1.zhimg.com/v2-4e74d5fdf0ed84d826b764c4046737cb.jpg?source=3af55fa1" data-image-width="1035" data-image-height="474" class=" wrap external" target="_blank" rel="nofollow noreferrer">支持 64 位架构  |  Google Play  |  Android Developers</a><p data-pid="d_63W8M9">巨型app淘宝和微信都已经实现了完全过渡到64位（国内市场也只发64位包），我不觉得其他app屎山有这两家严重，解决起来肯定比这两家容易得多</p><p data-pid="ZjFatQAn">这都还不上64位，就是单纯的坏透了</p><p><br></p><h2>0x1 能用Document API，为什么还要存储权限</h2><p data-pid="n0AlgrX1">还是经典的存储拉屎问题，只不过现在拉屎的必要性更低了</p><p data-pid="QJ4eqACq">除去老生常谈的私有无需分享的数据本来就应该在data目录，这次要谈的是，少量共享文件，也不需要存储权限</p><p data-pid="DIDdDjky">使用Content Provider可以为你需要共享的文件生成一个带授权的Intent，只需要把这个Intent传入其他APP，其他APP即可读取你授权的文件，哪怕这个文件本身在私有目录</p><p data-pid="siMtMWjI">示例：Solid Explorer通过Content Provider传递一张图片给Chrome，虽然Chrome没有存储权限，但可以读取这张图片</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-cab207e0735ae3725cf4c3e9024a189b_720w.jpg?source=3af55fa1" data-rawwidth="1080" data-rawheight="2340" data-size="normal" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-cab207e0735ae3725cf4c3e9024a189b_r.jpg?source=3af55fa1"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='1080'%20height='2340'&gt;&lt;/svg&gt;" data-rawwidth="1080" data-rawheight="2340" data-size="normal" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-cab207e0735ae3725cf4c3e9024a189b_r.jpg?source=3af55fa1" data-actualsrc="https://pic3.zhimg.com/v2-cab207e0735ae3725cf4c3e9024a189b_720w.jpg?source=3af55fa1"></figure><p data-pid="zull5gA2">使用Document API则可以在没有存储权限的情况下保存文件，通过调用Document让用户授权一个特定文件夹，即可授予该APP对特定文件夹的读写权限，无需完整的存储权限</p><p data-pid="CWjyU844">示例：Shizuku通过Document API保存文件到本地目录</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-37ff9786410fea61eb6c1ce2c48f91f5_720w.jpg?source=3af55fa1" data-rawwidth="1080" data-rawheight="2340" data-size="normal" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-37ff9786410fea61eb6c1ce2c48f91f5_r.jpg?source=3af55fa1"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='1080'%20height='2340'&gt;&lt;/svg&gt;" data-rawwidth="1080" data-rawheight="2340" data-size="normal" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-37ff9786410fea61eb6c1ce2c48f91f5_r.jpg?source=3af55fa1" data-actualsrc="https://pic3.zhimg.com/v2-37ff9786410fea61eb6c1ce2c48f91f5_720w.jpg?source=3af55fa1"></figure><p data-pid="dXmrBl5w">从SDK30起，应用默认只能通过运行权限申请媒体文件存储权限，不再可以任意读写公共存储，除非申请管理全部文件权限（需打开设置页面），大概这就是某些毒瘤不肯上30的原因吧</p><p data-pid="mDIkgekr">对了，SDK29开始，Download目录不需要存储权限了，要下载文件到公共存储的话，直接下载到Download目录就完事了</p><p data-pid="WZQPEgy0">那么到底还有什么是必须申请存储权限的呢？显然只有文件管理类，下载类等需要在公共存储操作大量文件或进行复杂文件处理的APP。Document API本身就不是为了高文件吞吐性能设计的，高吞吐需求还是要直接读写</p><h2>总之目前除了极少数有文件处理功能的APP外，其他APP全部没有申请存储权限的必要性</h2><p><br></p><h2>0x2 电话权限的屎坑，该清清了</h2><p data-pid="R-pOfLdQ">以前电话权限能拿IMEI，没错，但10.0开始，只有系统应用才能拿IMEI了，你普通APP就算拿了电话权限，也拿不到IMEI</p><p data-pid="xqJmmdZT">那你还申请个锤子电话权限啊，更不要说拿IMEI这种不可改变的唯一标识符本身就涉嫌过度收集用户信息</p><p data-pid="Da7Uv8RF">当然，我知道收集设备标识是有必要的，所以我仍然建议遵守谷歌官方的指南</p><a data-draft-node="block" data-draft-type="link-card" href="http://link.zhihu.com/?target=https%3A//developer.android.com/training/articles/user-data-ids%3Fhl%3Dzh-cn" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">developer.android.com/t</span><span class="invisible">raining/articles/user-data-ids?hl=zh-cn</span><span class="ellipsis"></span></a><p data-pid="wuQ1uffc">至于简单的拨打电话的功能，传一个Intent给拨号器就行了，不需要电话权限</p><h2>只有需要全自动拨号的，比如部分Tasker自定义任务，才必须使用电话权限，其余APP没有任何申请电话权限的必要性</h2><p><br></p><h2>0x3 关闭推送不应残留推送服务</h2><p data-pid="ad4PCPN9">一些APP提供了推送开关，或通过系统通知权限管理，但关闭推送之后，观察运行的Service却发现推送服务还在运行，仅仅是没有新通知</p><p data-pid="OwNLkwOT">这显然也是不可取的。当用户已经关闭通知后，APP应该彻底停止其推送服务。目前国内各大推送SDK均提供禁用接口，而自有推送服务直接StopService就行了，没有技术难度</p><p data-pid="OFwD4pDO">同样，如果系统级推送注册成功，也应该关闭APP自身一切推送服务，不应该重复推送浪费系统资源</p><p><br></p><h2>0x4 开屏太久不是好习惯</h2><p data-pid="UDubRfIf">开屏时间越长，用户流失也越多。个人认为一个完全静态的开屏页面不应该超过2秒</p><p data-pid="22-IYcHj">开屏慢分两种，一种是直接postDelay延迟了太久，比如Yeelight延迟了整整三秒，这种把postDelay去掉就ok了</p><p data-pid="8s1QcSCK">第二种就是纯粹的载入的东西太多了。这种的特点就是如果我先用一个intent把application拉起来，再打开开屏就快很多</p><p data-pid="7doVen1r">app启动时会先走完Application的init和onCreate，然后再是Activity的</p><p data-pid="rmQPDhKQ">Application里面主要的问题就是一次性载入的SDK太多，而且没有异步加载。解决办法很简单，新建一个线程单独加载，适当延迟一定时间加载非必要SDK（如统计，广告等）</p><p data-pid="vElh_OZZ">Activity里面主要问题是需要加载的资源太多，解决办法除了减少载入的内容外就还是异步，宁可先进主界面再转圈，用户体验也比缓慢的开屏要好得多</p><p data-pid="xlC-gF6e">大部分加载过多的问题，都源自于依Demo画瓢。大部分SDK的Demo本身东西就少，主线程同步加载没什么性能影响。但你整合到正式的APP，就不能这么依Demo画瓢，必须自己做性能优化</p><p><br></p><h2>0x5 跟上最新的SDK版本是有意义的</h2><p data-pid="P4lsolK1">如果你的targetSDK并不是最新的，那么你的APP会被系统做兼容性处理，无法使用最新的系统特性，也无法享受最高性能</p><p data-pid="cwczBFUd">同时由于AndroidSDK是在不断演进的，旧SDK的部分接口可能下个版本就被抛弃了，如果你不能及时跟进，就会出现异常</p><p data-pid="Ex8U-LBf">我建议当新SDK版本正式发布时，就开始着手适配新的SDK版本，尽可能最多落后SDK一个版本。如果实在无法及时适配，可以两个版本适配一次，但不管怎么样绝对不应该停留在项目最初的SDK版本上</p><p data-pid="UzGN0ZoU">目前最新SDK为30，谷歌play要求SDK28以上，国内工信部要求SDK26以上，若SDK版本过低，上架也可能受阻</p><p><br></p><h2>0x6 学会交给系统处理一些事</h2><p data-pid="WUAQ5CWg">对于系统提供了的组件，我一直认为不应该再在系统里造轮子</p><p data-pid="OyXLzJna">几个典型就是相册，拍照等功能，完全都不需要自己造轮子，全部直接调用系统组件就行了</p><p data-pid="v-H73ZD-">系统的东西绝对是在用户设备上兼容性最优的，能交给系统就交给系统不但可以减小包体积，加快运行速度，而且可以减少大量的兼容性问题</p><p><br></p><h2>0x7 全包加固不可取</h2><p data-pid="__zcaSnI">加固不是问题，全局加固是问题</p><p data-pid="UqmA7m1a">我自己开发的app也会在关键方法上做加固，但我坚决反对对整个dex全部加固。现代软件都会使用大量的第三方库，这些第三方库可以被轻易的获取，对这些库的代码也一并加密只会降低软件运行效率，而不会有任何好处</p><p data-pid="slwU4tLj">对于自己写出来的组件，也不是全部需要加固，一些ui类操作完全没有加固的必要。我个人坚持认为只有核心的必须保护的极少数代码需要加固保护，一般不应该超过全部代码的5%，而这部分的保护强度应该足够大。在极少数代码上牺牲性能换最强保护，而剩下的代码全部性能优先，是最均衡的选择，可以真正实现用户无法感知的性能损失</p><p data-pid="JGLV5b4A">(给个参考：我自己的app加固前启动速度110ms左右，加固后117ms左右，额外损耗仅7ms，我的方案是局部Dex2C+强签名校验)</p><p><br></p><h2>0x8 X5Webview并不好用</h2><p data-pid="WOo9Xjbh">系统Webview目前普遍都版本较高（最新已经达到了90），而X5目前还停留在69，显然低于系统内核。加上系统Webview默认多进程渲染，还常驻内存，载入也更快。（X5目前已经可以开多进程了，但是默认不开启）同时系统Webview长按选择后可调用系统APP处理，如调用谷歌翻译，但X5长按只有复制搜索分享。X5目前唯一的少量优势是WebGL性能略微优于系统Webview。但X5会消耗用户大约100M内置存储空间，100M空间换单单一个WebGL性能放弃其他系统内核优点，显然不值得</p><p><br></p><h2>这篇文章就不点名了，各APP自己对号入座</h2><p data-pid="D3rgGOuA">几年后重写同名文章，我很欣慰已经看到一些APP做出了改变，改善了用户体验，但维护软件生态任重道远，还需要更多人的参与和配合</p><h2>当用户设备开始卡顿时，没有哪个程序员是无辜的</h2><h2>在全球缺芯的今天，我们绝不应把希望继续寄托于芯片进步，软件优化迫在眉睫</h2>